"use strict";
/**
 * Copyright 2018 Google LLC
 *
 * Distributed under MIT license.
 * See file LICENSE for detail or copy at https://opensource.org/licenses/MIT
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ConfigStore = require("configstore");
var crypto_1 = require("crypto");
var google_auth_library_1 = require("google-auth-library");
var Pumpify = require("pumpify");
var r = require("request");
var stream_1 = require("stream");
var streamEvents = require("stream-events");
var request = r.defaults({ json: true, pool: { maxSockets: Infinity } });
var BASE_URI = 'https://www.googleapis.com/upload/storage/v1/b';
var TERMINATED_UPLOAD_STATUS_CODE = 410;
var RESUMABLE_INCOMPLETE_STATUS_CODE = 308;
var RETRY_LIMIT = 5;
var wrapError = function (message, err) {
    return new Error([message, err.message].join('\n'));
};
var Upload = /** @class */ (function (_super) {
    __extends(Upload, _super);
    function Upload(cfg) {
        var _this = _super.call(this) || this;
        _this.numBytesWritten = 0;
        _this.numRetries = 0;
        streamEvents.call(_this);
        cfg = cfg || {};
        if (!cfg.bucket || !cfg.file) {
            throw new Error('A bucket and file name are required');
        }
        cfg.authConfig = cfg.authConfig || {};
        cfg.authConfig.scopes =
            ['https://www.googleapis.com/auth/devstorage.full_control'];
        _this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);
        _this.bucket = cfg.bucket;
        _this.file = cfg.file;
        _this.generation = cfg.generation;
        _this.kmsKeyName = cfg.kmsKeyName;
        _this.metadata = cfg.metadata || {};
        _this.offset = cfg.offset;
        _this.origin = cfg.origin;
        _this.userProject = cfg.userProject;
        if (cfg.key) {
            /**
             * NOTE: This is `as string` because there appears to be some weird kind
             * of TypeScript bug as 2.8. Tracking the issue here:
             * https://github.com/Microsoft/TypeScript/issues/23155
             */
            var base64Key = Buffer.from(cfg.key).toString('base64');
            _this.encryption = {
                key: base64Key,
                hash: crypto_1.createHash('sha256').update(cfg.key).digest('base64')
            };
        }
        _this.predefinedAcl = cfg.predefinedAcl;
        if (cfg.private)
            _this.predefinedAcl = 'private';
        if (cfg.public)
            _this.predefinedAcl = 'publicRead';
        _this.configStore = new ConfigStore('gcs-resumable-upload');
        _this.uriProvidedManually = !!cfg.uri;
        _this.uri = cfg.uri || _this.get('uri');
        _this.numBytesWritten = 0;
        _this.numRetries = 0;
        var contentLength = cfg.metadata ? Number(cfg.metadata.contentLength) : NaN;
        _this.contentLength = isNaN(contentLength) ? '*' : contentLength;
        _this.once('writing', function () {
            if (_this.uri) {
                _this.continueUploading();
            }
            else {
                _this.createURI(function (err) {
                    if (err) {
                        return _this.destroy(err);
                    }
                    _this.startUploading();
                });
            }
        });
        return _this;
    }
    Upload.prototype.createURI = function (callback) {
        var _this = this;
        var metadata = this.metadata;
        var reqOpts = {
            method: 'POST',
            url: [BASE_URI, this.bucket, 'o'].join('/'),
            params: { name: this.file, uploadType: 'resumable' },
            data: metadata,
            headers: {}
        };
        if (metadata.contentLength) {
            reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength;
        }
        if (metadata.contentType) {
            reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;
        }
        if (typeof this.generation !== 'undefined') {
            reqOpts.params.ifGenerationMatch = this.generation;
        }
        if (this.kmsKeyName) {
            reqOpts.params.kmsKeyName = this.kmsKeyName;
        }
        if (this.predefinedAcl) {
            reqOpts.params.predefinedAcl = this.predefinedAcl;
        }
        if (this.origin) {
            reqOpts.headers.Origin = this.origin;
        }
        this.makeRequest(reqOpts, function (err, resp) {
            if (err) {
                return callback(err);
            }
            var uri = resp.headers.location;
            _this.uri = uri;
            _this.set({ uri: uri });
            _this.offset = 0;
            callback(null, uri);
        });
    };
    Upload.prototype.continueUploading = function () {
        if (typeof this.offset === 'number') {
            return this.startUploading();
        }
        this.getAndSetOffset(this.startUploading.bind(this));
    };
    Upload.prototype.startUploading = function () {
        var _this = this;
        var reqOpts = {
            method: 'PUT',
            url: this.uri,
            headers: {
                'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength
            }
        };
        var bufferStream = this.bufferStream = new stream_1.PassThrough();
        var offsetStream = this.offsetStream =
            new stream_1.PassThrough({ transform: this.onChunk.bind(this) });
        var delayStream = new stream_1.PassThrough();
        this.getRequestStream(reqOpts, function (requestStream) {
            _this.setPipeline(bufferStream, offsetStream, requestStream, delayStream);
            // wait for "complete" from request before letting the stream finish
            delayStream.on('prefinish', function () {
                _this.cork();
            });
            requestStream.on('complete', function (resp) {
                if (resp.statusCode < 200 || resp.statusCode > 299) {
                    _this.destroy(new Error('Upload failed'));
                    return;
                }
                _this.emit('metadata', resp.body);
                _this.deleteConfig();
                _this.uncork();
            });
        });
    };
    Upload.prototype.onChunk = function (chunk, enc, next) {
        var offset = this.offset;
        var numBytesWritten = this.numBytesWritten;
        // check if this is the same content uploaded previously. this caches a
        // slice of the first chunk, then compares it with the first byte of
        // incoming data
        if (numBytesWritten === 0) {
            var cachedFirstChunk = this.get('firstChunk');
            var firstChunk = chunk.slice(0, 16).valueOf();
            if (!cachedFirstChunk) {
                // This is a new upload. Cache the first chunk.
                this.set({ uri: this.uri, firstChunk: firstChunk });
            }
            else {
                // this continues an upload in progress. check if the bytes are the same
                cachedFirstChunk = Buffer.from(cachedFirstChunk);
                var nextChunk = Buffer.from(firstChunk);
                if (Buffer.compare(cachedFirstChunk, nextChunk) !== 0) {
                    // this data is not the same. start a new upload
                    this.bufferStream.unshift(chunk);
                    this.bufferStream.unpipe(this.offsetStream);
                    this.restart();
                    return;
                }
            }
        }
        var length = chunk.length;
        if (typeof chunk === 'string')
            length = Buffer.byteLength(chunk, enc);
        if (numBytesWritten < offset)
            chunk = chunk.slice(offset - numBytesWritten);
        this.numBytesWritten += length;
        // only push data from the byte after the one we left off on
        next(null, this.numBytesWritten > offset ? chunk : undefined);
    };
    Upload.prototype.getAndSetOffset = function (callback) {
        var _this = this;
        var opts = {
            method: 'PUT',
            url: this.uri,
            headers: { 'Content-Length': 0, 'Content-Range': 'bytes */*' }
        };
        this.makeRequest(opts, function (err, resp) {
            if (err) {
                // we don't return a 404 to the user if they provided the resumable
                // URI. if we're just using the configstore file to tell us that this
                // file exists, and it turns out that it doesn't (the 404), that's
                // probably stale config data.
                if (resp && resp.status === 404 && !_this.uriProvidedManually) {
                    return _this.restart();
                }
                // this resumable upload is unrecoverable (bad data or service error).
                //  -
                //  https://github.com/stephenplusplus/gcs-resumable-upload/issues/15
                //  -
                //  https://github.com/stephenplusplus/gcs-resumable-upload/pull/16#discussion_r80363774
                if (resp && resp.status === TERMINATED_UPLOAD_STATUS_CODE) {
                    return _this.restart();
                }
                return _this.destroy(err);
            }
            if (resp && resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {
                if (resp.headers.range) {
                    var range = resp.headers.range;
                    _this.offset = Number(range.split('-')[1]) + 1;
                    callback();
                    return;
                }
            }
            _this.offset = 0;
            callback();
        });
    };
    Upload.prototype.makeRequest = function (reqOpts, callback) {
        if (this.encryption) {
            reqOpts.headers = reqOpts.headers || {};
            reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';
            reqOpts.headers['x-goog-encryption-key'] = this.encryption.key;
            reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash;
        }
        if (this.userProject) {
            reqOpts.params = reqOpts.params || {};
            reqOpts.params.userProject = this.userProject;
        }
        reqOpts.validateStatus = function (status) {
            return (status >= 200 && status < 300) ||
                status === RESUMABLE_INCOMPLETE_STATUS_CODE;
        };
        this.authClient.request(reqOpts).then(function (r) {
            return callback(null, r, r.data);
        }, function (err) {
            var body = err.response ? err.response.data : undefined;
            var e = (body && body.error) ? body.error : err;
            return callback(e, err.response, body);
        });
    };
    Upload.prototype.getRequestStream = function (reqOpts, callback) {
        var _this = this;
        if (this.userProject) {
            reqOpts.params = reqOpts.params || {};
            reqOpts.params.userProject = this.userProject;
        }
        this.authClient.authorizeRequest(reqOpts)
            .then(function (opts) {
            var authorizedReqOpts = axiosToRequest(reqOpts);
            var requestStream = request(authorizedReqOpts);
            requestStream.on('error', _this.destroy.bind(_this));
            requestStream.on('response', _this.onResponse.bind(_this));
            requestStream.on('complete', function (resp) {
                var body = resp.body;
                if (body && body.error)
                    _this.destroy(body.error);
            });
            // this makes the response body come back in the response (weird?)
            requestStream.callback = function () { };
            callback(requestStream);
        })
            .catch(function (err) {
            return _this.destroy(wrapError('Could not authenticate request', err));
        });
    };
    Upload.prototype.restart = function () {
        var _this = this;
        this.numBytesWritten = 0;
        this.deleteConfig();
        this.createURI(function (err) {
            if (err) {
                return _this.destroy(err);
            }
            _this.startUploading();
        });
    };
    Upload.prototype.get = function (prop) {
        var store = this.configStore.get([this.bucket, this.file].join('/'));
        return store && store[prop];
    };
    // tslint:disable-next-line no-any
    Upload.prototype.set = function (props) {
        this.configStore.set([this.bucket, this.file].join('/'), props);
    };
    Upload.prototype.deleteConfig = function () {
        this.configStore.delete([this.bucket, this.file].join('/'));
    };
    /**
     * @return {bool} is the request good?
     */
    Upload.prototype.onResponse = function (resp) {
        if (resp.status === 404) {
            if (this.numRetries < RETRY_LIMIT) {
                this.numRetries++;
                this.startUploading();
            }
            else {
                this.destroy(new Error('Retry limit exceeded'));
            }
            return false;
        }
        if (resp.status > 499 && resp.status < 600) {
            if (this.numRetries < RETRY_LIMIT) {
                var randomMs = Math.round(Math.random() * 1000);
                var waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs;
                this.numRetries++;
                setTimeout(this.continueUploading.bind(this), waitTime);
            }
            else {
                this.destroy(new Error('Retry limit exceeded'));
            }
            return false;
        }
        this.emit('response', resp);
        return true;
    };
    return Upload;
}(Pumpify));
exports.Upload = Upload;
function axiosToRequest(opts) {
    var reqOpts = opts;
    reqOpts.qs = opts.params;
    reqOpts.json = opts.data;
    reqOpts.uri = opts.url;
    return reqOpts;
}
function upload(cfg) {
    return new Upload(cfg);
}
exports.upload = upload;
function createURI(cfg, callback) {
    var up = new Upload(cfg);
    up.createURI(callback);
}
exports.createURI = createURI;
//# sourceMappingURL=index.js.map